package Imaging::Routes::locations;
use Dancer ':syntax';
use Dancer::Plugin::Imaging::Routes::Common;
use Dancer::Plugin::Imaging::Routes::Meercat;
use Dancer::Plugin::Auth::RBAC;
use Dancer::Plugin::Database;
use Catmandu::Sane;
use Catmandu qw(store);
use Catmandu::Util qw(:is);
use Data::Pageset;
use Try::Tiny;
use URI::Escape qw(uri_escape);
use List::MoreUtils qw(first_index);

sub core {
    state $core = store("core");
}
sub indexer {
    state $index = store("index")->bag("locations");
}
sub locations {
    state $locations = core()->bag("locations");
}
sub projects {
    state $projects = core()->bag("projects");
}
sub dbi_handle {
    state $dbi_handle = database;
}
hook before => sub {
    if(request->path =~ /^\/locations/o){
		if(!authd){
			my $service = uri_escape(uri_for(request->path));
			return redirect(uri_for("/login")."?service=$service");
		}
	}
};
any('/locations',sub {
	my $params = params;
    my $indexer = indexer();
    my $q = is_string($params->{q}) ? $params->{q} : "*";

    my $page = is_natural($params->{page}) && int($params->{page}) > 0 ? int($params->{page}) : 1;
    $params->{page} = $page;
    my $num = is_natural($params->{num}) && int($params->{num}) > 0 ? int($params->{num}) : 20;
    $params->{num} = $num;
    my $offset = ($page - 1)*$num;
    my $sort = $params->{sort};

    my %opts = (
        query => $q,
        start => $offset,
        limit => $num
    );
    $opts{sort} = $sort if $sort && $sort =~ /^\w+\s(?:asc|desc)$/o;
	my @errors = ();
    my($result);
    try {
        $result= indexer->search(%opts);
    }catch{
		push @errors,"ongeldige zoekvraag";
    };
    if(scalar(@errors)==0){
        my $page_info = Data::Pageset->new({
            'total_entries'       => $result->total,
            'entries_per_page'    => $num,
            'current_page'        => $page,
            'pages_per_set'       => 8,
            'mode'                => 'fixed'
        });
        template('locations',{
            locations => $result->hits,
            page_info => $page_info,
            auth => auth(),
            mount_conf => mount_conf()
        });
    }else{
        template('locations',{
            locations => [],
            errors => \@errors,
            auth => auth(),
            mount_conf => mount_conf()
        });
    }
});
any('/locations/view',sub {
    my $params = params;
    my $indexer = indexer();
    $params->{q} = is_string($params->{q}) ? $params->{q} : "*";
    $params->{start} = is_natural($params->{start}) && int($params->{start}) >= 0 ? int($params->{start}) : 0;
    my %opts = (
        query => $params->{q},
        reify => locations(),
        start => $params->{start},
        limit => 1
    );
	my @errors = ();
    my($result);
    try {
        $result = indexer->search(%opts);
    }catch{
		push @errors,"ongeldige zoekvraag";
    };
    if(scalar(@errors)==0){
        my $project;
        if($result->hits->[0]->{project_id}){
            $project = projects->get($result->hits->[0]->{project_id});
        }
		#comment - start
		if(is_string($params->{comment})){
			push @{ $result->hits->[0]->{comments} ||= [] },{
				'time' => time,
				text => $params->{comment},
				user_name => session('user')->{login}
			};
			locations->add($result->hits->[0]);
		}
		#comment - end
        template('locations/view',{
            location => $result->hits->[0],
            auth => auth(),
            errors => \@errors,
            mount_conf => mount_conf(),
            project => $project,
            user => dbi_handle->quick_select('users',{ id => $result->hits->[0]->{user_id} })
        });
    }else{
        template('locations/view',{
            location => [],
            errors => \@errors,
            auth => auth(),
            mount_conf => mount_conf()
        });
    }
});
any('/locations/view/:_id',sub {
    my $params = params;
    my $_id = delete $params->{_id};
    $params->{q} = "_id:\"$_id\"";
    redirect(uri_for('/locations/view',$params));
});


any('/locations/edit',sub{
	my $params = params;
	my $auth = auth;
	if(!($auth->asa('admin') || $auth->can('locations','edit'))){
        return forward('/access_denied',{
            text => "U mist de nodige gebruikersrechten om dit record te kunnen aanpassen"
        });
    }


    my $indexer = indexer();
    $params->{q} = is_string($params->{q}) ? $params->{q} : "*";
    $params->{start} = is_natural($params->{start}) && int($params->{start}) >= 0 ? int($params->{start}) : 0;
    my %opts = (
        query => $params->{q},
        reify => locations(),
        start => $params->{start},
        limit => 1
    );
	my @errors = ();
    my($result);
    try {
        $result = indexer->search(%opts);
    }catch{
        push @errors,"ongeldige zoekvraag";
    };
    if(scalar(@errors)==0){
        my $project;
        if($result->hits->[0]->{project_id}){
            $project = projects->get($result->hits->[0]->{project_id});
        }
		#edit - start 
		my($location,$errs) = edit_location($result->hits->[0]);
		push @errors,@$errs;
		if(scalar(@$errs)==0){
			locations->add($location);
		}
		#edit - end	
        template('locations/edit',{
            location => $result->hits->[0],
            auth => auth(),
            errors => \@errors,
            mount_conf => mount_conf(),
            project => $project,
            user => dbi_handle->quick_select('users',{ id => $result->hits->[0]->{user_id} })
        });
    }else{
        template('locations/edit',{
            location => [],
            errors => \@errors,
            auth => auth(),
            mount_conf => mount_conf()
        });
    }
});

any('/locations/edit/:_id',sub {
    my $params = params;
    my $_id = delete $params->{_id};
    $params->{q} = "_id:\"$_id\"";
    redirect(uri_for('/locations/edit',$params));
});

sub edit_location {
	my $location = shift;
	my $params = params;
	my @errors = ();
	my $action = $params->{action} || "";

	$location->{metadata} ||= [];

	#past metadata_id aan => verwacht dat er 0 of 1 element in 'metadata' zit
	if($action eq "edit_metadata_id"){
		
		if(is_array_ref($location->{metadata}) && scalar(@{$location->{metadata}}) > 1){

			push @errors,"Dit record bevat meerdere metadata records. Verwijder eerst de overbodige.";

		}else{

			my @keys = qw(metadata_id);
			foreach my $key(@keys){
				if(!is_string($params->{$key})){
					push @errors,"$key is niet opgegeven";
				}		
			}
			if(scalar(@errors)==0){
				my($result,$total,$error);
				try {

					$result = meercat->search($params->{metadata_id});		
					$total = $result->content->{response}->{numFound};

				}catch{
					$error = $_;
					print $_;
				};
				if($error){
					push @errors,"query $params->{metadata_id_to} is ongeldig";
				}elsif($total > 1){
					push @errors,"query $params->{metadata_id_to} leverde meer dan één resultaat op";
				}elsif($total == 0){
					push @errors,"query $params->{metadata_id_to} leverde geen resultaten op";
				}else{
					my $doc = $result->content->{response}->{docs}->[0];
					$location->{metadata} = [{
						fSYS => $doc->{fSYS},#000000001
						source => $doc->{source},#rug01
						fXML => $doc->{fXML},
						baginfo => marcxml2baginfo($doc->{fXML})			
					}];
				}
			}
		}
	}
	#verwijder element met metadata_id uit de lijst (mag resulteren in 0 elementen)
	elsif($action eq "delete_metadata_id"){

		my @keys = qw(metadata_id);
        foreach my $key(@keys){
            if(!is_string($params->{$key})){
                push @errors,"$key is niet opgegeven";
            }
        }
		if(scalar(@errors)==0){
			my $index = first_index { $_->{source}.":".$_->{fSYS} eq $params->{metadata_id} } @{$location->{metadata}};
			if($index >= 0){
				splice @{$location->{metadata}},$index,1;
			}
		}
	}
	#voeg dc-elementen toe
	elsif($action eq "add_baginfo_pair"){

		if(is_array_ref($location->{metadata}) && scalar(@{$location->{metadata}}) > 1){

            push @errors,"Dit record bevat meerdere metadata records. Verwijder eerst de overbodige.";

        }else{

			my @keys = qw(key value);
			foreach my $key(@keys){
				if(!is_string($params->{$key})){
					push @errors,"$key is niet opgegeven";
				}
			}
			if(scalar(@errors)==0){
				my $key = $params->{key};
				my $value = $params->{value};
				$location->{metadata}->[0]->{baginfo}->{$key} ||= [];
				push @{ $location->{metadata}->[0]->{baginfo}->{$key} },$value;
			}

		}
	}elsif($action eq "edit_baginfo"){

		my @keys = do {
			my $config = config;
			my @values = ();
			foreach(@{$config->{app}->{locations}->{baginfo}}){
				push @values,$_->{key};
			}
			@values;
		};
		my $baginfo = {};
		foreach my $key(@keys){
            if(!is_string($params->{$key})){
                push @errors,"$key is niet opgegeven";
            }else{
				$baginfo->{$key} = is_array_ref($params->{$key}) ? $params->{$key} : [$params->{$key}];
			}
		}
		if(scalar(@errors)==0){
			$location->{baginfo} = $baginfo;
		}
		
	}
	return $location,\@errors;
}

true;
